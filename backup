// executeSQLWithTx executes an SQL statement from the specified file
func executeSQLWithTx(ctx context.Context, tx *sql.Tx, filePath string, args ...interface{}) error {
	// If the provided context is nil, use the default background context.
	// 방어적 프로그램(defensive programming) 관점에서 작성하는 것이 유리함. TODO 일단 생각해보자.
	if ctx == nil {
		ctx = context.Background()
	}

	// Read the SQL file content.
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("SQL 파일 읽기 실패 (%s): %w", filePath, err)
	}

	// Trim any unnecessary whitespace from the SQL query.
	query := strings.TrimSpace(string(content))
	if query == "" {
		return fmt.Errorf("SQL 파일 (%s)이 비어 있습니다", filePath)
	}

	// Execute the SQL query within the transaction using ExecContext.
	_, err = tx.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("SQL 실행 실패 (%s): %w", filePath, err)
	}

	return nil
}

// executeSQLTx 컨텍스트 없이 호출할 때 사용
func executeSQLTx(tx *sql.Tx, filePath string, args ...interface{}) error {
	return executeSQLWithTx(context.Background(), tx, filePath, args...)
}

func executeSQLWithDB(ctx context.Context, db *sql.DB, filePath string, args ...interface{}) error {
	// If the provided context is nil, use the default background context.
	// 방어적 프로그램(defensive programming) 관점에서 작성하는 것이 유리함.
	// 예전에 nil 이면 그냥 에러 처리했는데. 이렇게 하는게 더 좋은듯. TODO 일단 생각해보자.
	if ctx == nil {
		ctx = context.Background()
	}

	// Read the SQL file content.
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read SQL file (%s): %w", filePath, err)
	}

	// Trim whitespace and check if the file is empty.
	query := strings.TrimSpace(string(content))
	if query == "" {
		return fmt.Errorf("SQL file (%s) is empty", filePath)
	}

	// Execute the SQL statement using ExecContext.
	_, err = db.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("failed to execute SQL statement from file (%s): %w", filePath, err)
	}

	return nil
}

func executeSQLDB(db *sql.DB, filePath string, args ...interface{}) error {
	return executeSQLWithDB(context.Background(), db, filePath, args...)
}

// TODO 여기서 생각할 것이 루트 폴더를 기준으로 그 밑의 1차적인 하위 폴더만의 리스트를 먼저 가지고 있어야 한다. 그래서 아래의 메서드들을 이용해서 db 를 채워야 한다.

// FirstCheck 한번만 실행되고 말것. folderPath 검증 해야함. TODO 디렉토리 검증되는지 확인해야 함.
func FirstCheck(ctx context.Context, db *sql.DB, folderPath string) error {

	if ctx == nil {
		ctx = context.Background()
	}

	if utils.IsEmptyString(folderPath) {
		return fmt.Errorf("폴더 경로가 비어 있습니다")
	}

	// 1. 트랜잭션 시작 (Context-aware)
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("트랜잭션 시작 실패: %w", err)
	}

	// 2. 폴더 정보 삽입 (Context-aware executeSQLTx 사용)
	folder := Folder{
		Path:        folderPath,
		TotalSize:   0,
		FileCount:   0,
		CreatedTime: time.Now().Format("2006-01-02 15:04:05"),
	}

	err = executeSQLWithTx(ctx, tx, "queries/insert_folder.sql", folder.Path, folder.TotalSize, folder.FileCount, folder.CreatedTime)
	if err != nil {
		tx.Rollback()
		return fmt.Errorf("폴더 삽입 실패: %w", err)
	}

	// 3. 폴더 ID 가져오기 (Context-aware QueryRow)
	var folderID int64
	err = tx.QueryRowContext(ctx, "SELECT id FROM folders WHERE path = ?", folder.Path).Scan(&folderID)
	if err != nil {
		tx.Rollback()
		return fmt.Errorf("폴더 ID 조회 실패: %w", err)
	}

	// 4. 폴더 내 파일 목록 가져오기 (여기서는 Context 사용이 필요하지 않을 수도 있음)
	filesInfo, err := GetFilesWithSize(folderPath)
	if err != nil {
		tx.Rollback()
		return fmt.Errorf("폴더 내 파일 정보 가져오기 실패: %w", err)
	}

	// 5. 파일 정보를 DB에 삽입 (Context-aware executeSQLTx 사용)
	for name, size := range filesInfo {
		err = executeSQLWithTx(ctx, tx, "queries/insert_file.sql", folderID, name, size, time.Now().Format("2006-01-02 15:04:05"))
		if err != nil {
			tx.Rollback()
			return fmt.Errorf("파일 삽입 실패: %w", err)
		}
	}

	// 6. 폴더의 total_size 및 file_count 업데이트 (Context-aware)
	err = executeSQLWithTx(ctx, tx, "queries/update_folders_fromDB.sql", folderID)
	if err != nil {
		tx.Rollback()
		return fmt.Errorf("폴더 통계 업데이트 실패: %w", err)
	}

	// 7. 트랜잭션 커밋
	err = tx.Commit()
	if err != nil {
		return fmt.Errorf("트랜잭션 커밋 실패: %w", err)
	}

	return nil
}

func InitializeDatabase(db *sql.DB) error {
	// 데이터베이스가 초기화되지 않았다면 init.sql 실행
	if !isDBInitialized(db) {
		log.Println("Running database initialization...")
		if err := executeSQLDB(db, "queries/init.sql"); err != nil {
			return fmt.Errorf("DB 초기화 실패: %w", err)
		}
		log.Println("Database initialization completed successfully.")
	} else {
		log.Println("Database already initialized. Skipping init.sql execution.")
	}
	return nil
}

// nameparsing.go
package parsing

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

/*func main() {
	// var totalfiles [][]string
	// 루트 디렉토리에서 각 디렉토리를 recursive 하게 탐색해서 파일명을 가져와야 한다.

	path := "/tmp/testfiles"
	// 테스트로 빈파일 생성
	MakeTestFiles(path)
	files, err := ReadAllFileNames1(path)
	if err != nil { // 에러 발생 시 종료
		fmt.Println("Error reading file names:", err)
		os.Exit(1)
	}
	for _, file := range files {
		fmt.Printf("%s\n", file)
	}
	// 그룹화 했음.
	groupedFiles := GroupFilesByExtension(files)

	err = ValidateKeyCount(groupedFiles, 1) // maxKeys를 1로 설정
	if err != nil {
		// key 가 여러개일경우 해당 디렉토리에 여러 확장자의 파일이 있다 이 경우 경고로 알려주고 datablock 작업을 하지 못한다.????
		// datablock 은 같은 확장자에 한해서 가능하도록 한다. 또는 그것을 구분지어준다.
		fmt.Println("Validation failed:", err)
	} else {
		fmt.Println("Validation passed: map contains acceptable number of keys.")
		isfastq, err := IsFastqFiles(groupedFiles)
		if err != nil {
			fmt.Println("Error:", err)
			os.Exit(1)
		}
		// fastq 일 경우
		if isfastq {
			// 일루니마 것인지 판단
			// 일루미나 포멧이라면 각 파트를 가져와서 구조체에 넣어줌.
			// 일루미나 포멧이 아니라면.
			// 일단 파일이름 구조체에 넣더움.
		}
		// fastq 가 아닐 경우
		// 일단 파일이름 구조체에 넣더움.
	}

	ExtractFileParts(files) // return [][]string
	// 그룹핑 해줘야 하는데...
	// 0. 특정 디렉토리 중심으로 필터링 됨.
	// 0.1 파일 확장자가 모두 동일한지를 먼저 판단해야함.
	// 0.1.1 만약 다를 경우 구분지어주어야 함. 그리고 error 리턴
	// 1. 파일 확장자로 먼저 일단 필터링.
	// 1.0 fastq 인경우 illumina 파일인지 먼저 판단함.
	// smaple, range 등등 구분함.
	// 1.0.1 paired end 인지 single 인지 판단함.

}*/

// 일단 임시로 이렇게 만듬.
var (
	fileName string
	filePath string
)

// 여기에 어떻게 잘 담을지 고민해야함.
type DataBlock struct {
	Original [][]string // 원본 데이터만 저장
	RowKeys  []string   // 행 키
	ColKeys  []string   // 열 키
}

func extractParts(fileName string) []string {
	var parts []string
	var currentPart []rune

	// 문자 유형을 판별하는 함수
	getRuneType := func(r rune) string {
		switch {
		case unicode.IsLetter(r):
			return "letter"
		case unicode.IsDigit(r):
			return "digit"
		case unicode.IsSpace(r):
			return "space"
		case unicode.IsSymbol(r):
			return "symbol"
		case unicode.IsPunct(r):
			return "punctuation"
		default:
			return "other"
		}
	}

	// 이전 문자의 유형
	var previousType string

	for _, r := range fileName {
		// 현재 문자의 유형
		currentType := getRuneType(r)

		// 현재 문자와 이전 문자의 유형이 다르면 새로운 파트 시작
		if len(currentPart) > 0 && currentType != previousType {
			parts = append(parts, string(currentPart)) // 이전 파트 저장
			currentPart = []rune{}                     // 새로운 파트 시작
		}

		// 현재 문자를 현재 파트에 추가
		currentPart = append(currentPart, r)
		previousType = currentType
	}

	// 마지막 남은 파트를 추가
	if len(currentPart) > 0 {
		parts = append(parts, string(currentPart))
	}

	return parts
}

// hasCombiningCharacter 조합문자 검출. 일단 조합문자는 막는 걸로 한다.
func hasCombiningCharacter(s string) bool {
	for _, r := range s {
		if unicode.IsMark(r) {
			return true
		}
	}
	return false
}

// 일단 유전체 데이터 일반적인 유전체 파일명 기준으로 맞추고 그것이 맞지 않는다면 별도의 파일명 기준을 찾아내는 방식으로 맞추는 방식으로 진행한다.

/*func isIlluminaParts(parts []string) bool {
	// Illumina 주요 파츠 검증
	// sample1_S1_L001_R1_001.fastq.gz를 예상
	partsCount := len(parts)
	if partsCount < 3 {
		return false
	} // 최소 3개 이상 sample.fastq (smaple . fastq)

	// "S1": 샘플 번호는 S로 시작하고 뒤에 숫자
	sampleIndex := -1
	for i, part := range parts {
		if strings.HasPrefix(part, "S") && isNumber(part[1:]) {
			sampleIndex = i
			break
		}
	}
	if sampleIndex == -1 {
		return false // S1이 없음
	}

	// "L001": 레인 번호는 L로 시작하고 뒤에 숫자
	laneIndex := -1
	for i, part := range parts {
		if strings.HasPrefix(part, "L") && isNumber(part[1:]) {
			laneIndex = i
			break
		}
	}
	if laneIndex == -1 {
		return false // L001이 없음
	}

	// "R1" 또는 "R2": 읽기 방향
	readIndex := -1
	for i, part := range parts {
		if part == "R1" || part == "R2" {
			readIndex = i
			break
		}
	}
	if readIndex == -1 {
		return false // R1 또는 R2가 없음
	}

	// "001": 반복 번호는 숫자여야 함
	repeatIndex := -1
	for i, part := range parts {
		if isNumber(part) {
			repeatIndex = i
			break
		}
	}
	if repeatIndex == -1 {
		return false // 반복 번호가 없음
	}

	// ".fastq.gz" 또는 ".fastq"로 끝나야 함
	if !strings.HasSuffix(parts[len(parts)-1], ".fastq.gz") && !strings.HasSuffix(parts[len(parts)-1], ".fastq") {
		return false // 확장자가 올바르지 않음
	}

	return true
}*/

// 이런식으로 하면 모든 확장자를 다 확인 해야 하는 어려움이 있음.
func findSuffixFastq(parts []string) (bool, string) {
	// sample.fastq 가 최소 조합임. => "sample", ".", "fastq"
	if len(parts) < 3 {
		return false, ""
	}

	if strings.HasSuffix(parts[len(parts)-1], "fastq") {
		return true, "fastq"
	}

	if strings.HasSuffix(parts[len(parts)-1], "fq") {
		return true, "fq"
	}
	// sample.fastq.gz 일 경우. => "sample", ".", "fastq", ".", "gz"
	if strings.HasSuffix(parts[len(parts)-1], "gz") {
		if strings.HasSuffix(parts[len(parts)-3], "fastq") {
			return true, "fastq.gz"
		}

		if strings.HasSuffix(parts[len(parts)-3], "fq") {
			return true, "fq.gz"
		}
	}

	return false, ""
}

// isNumber: 문자열이 숫자인지 확인
func isNumber(s string) bool {
	for _, r := range s {
		if !unicode.IsDigit(r) {
			return false
		}
	}
	return true
}

// 먼저 확장자 별로 묶어둔다.
// 특정 디렉토리에서 확장자별로 묶는다. 만약 특정 디렉토리에 확장자가 다른 것들이 있다면 각각 묶지만 에러를 리턴한다.
// 일단 파일을 묶는 것은 proto 방식으로 파일을 묶는다.

// ReadAllFileNames 특정 디렉토리에서 모든 파일 이름을 읽어오는 함수
func ReadAllFileNames(dirPath string) ([]string, error) {
	// 디렉토리의 파일 목록 읽기
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory %s: %w", dirPath, err)
	}

	// 파일 이름을 저장할 슬라이스
	var fileNames []string

	// 파일 목록에서 이름만 추출
	for _, file := range files {
		// 파일 이름을 경로와 함께 추가
		fileNames = append(fileNames, filepath.Join(dirPath, file.Name())) // Append to the End
	}

	return fileNames, nil
}

// ReadAllFileNames1 일단 임시로 만듬.
func ReadAllFileNames1(dirPath string) ([]string, error) {
	// 디렉토리의 파일 목록 읽기
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory %s: %w", dirPath, err)
	}

	// 파일 이름을 저장할 슬라이스
	var fileNames []string

	// 파일 목록에서 이름만 추출
	for _, file := range files {
		// 파일 이름을 경로와 함께 추가
		fileNames = append(fileNames, file.Name()) // Append to the End
	}

	return fileNames, nil
}

func ExtractFileParts(files []string) ([][]string, error) {
	var data [][]string
	var skippedFiles []string // 조합 문자가 포함된 파일 이름 목록

	for _, file := range files {
		if hasCombiningCharacter(file) {
			skippedFiles = append(skippedFiles, file) // 조합 문자 파일을 건너뜀
			continue
		}
		parts := extractParts(file)
		data = append(data, parts)
	}

	// 조합 문자 포함 파일이 있었는지 확인
	if len(skippedFiles) > 0 {
		errMsg := fmt.Sprintf("Skipped files with combining characters: %v", skippedFiles)
		return data, fmt.Errorf(errMsg)
	}

	return data, nil
}

func MakeTestFiles(path string) {
	// 디렉토리 생성
	err := os.MkdirAll(path, os.ModePerm)
	if err != nil {
		log.Fatalf("Failed to create directory %s: %v", path, err)
	}

	// 디렉토리 권한을 777로 설정 os.ModePerm 해줌.
	/*err = os.Chmod(path, 0777) //0o777 이 방식보다 0777 방식 사용
	if err != nil {
		log.Fatalf("Failed to set permissions for directory %s: %v", path, err)
	}*/

	// 테스트 파일 이름 목록
	fileNames := []string{
		"sample1_S1_L001_R1_001.fastq.gz",
		"sample1_S1_L001_R2_001.fastq.gz",
		"sample1_S1_L002_R1_001.fastq.gz",
		"sample2_S2_L001_R1_001.fastq.gz",
		"sample2_S2_L001_R2_001.fastq.gz",
	}

	// 파일 생성
	for _, fileName := range fileNames {
		filePath := fmt.Sprintf("%s/%s", path, fileName)
		_, err := os.Create(filePath)
		if err != nil {
			log.Fatalf("Failed to create file %s: %v", filePath, err)
		} else {
			log.Printf("Created file: %s", filePath)
		}
	}
}

// GetAllExtensions returns all extensions in a file name as a slice of strings.
func GetAllExtensions(fileName string) []string {
	var extensions []string
	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extensions = append([]string{ext}, extensions...) // Prepend to maintain order
		fileName = strings.TrimSuffix(fileName, ext)      // Remove the last extension
	}
	return extensions
}

func GetAllExtensionsAsString(fileName string) string {
	var extensions []string
	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extensions = append([]string{ext}, extensions...) // Prepend to maintain order
		fileName = strings.TrimSuffix(fileName, ext)      // Remove the last extension
	}
	return strings.Join(extensions, "") // Concatenate all extensions
}

func GetAllExtensionsAsString1(fileName string) (baseName string, extensions string) {
	var extList []string

	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extList = append([]string{ext}, extList...)  // Prepend to maintain order
		fileName = strings.TrimSuffix(fileName, ext) // Remove the last extension
	}

	baseName = fileName
	extensions = strings.Join(extList, "") // Combine extensions

	return baseName, extensions
}

func GetAllExtensionsAsStringOptimized(fileName string) string {
	var extensions string
	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extensions = ext + extensions                // Prepend directly to the result string
		fileName = strings.TrimSuffix(fileName, ext) // Remove the last extension
	}
	return extensions
}

// GroupFilesByExtension 확장자별로 파일 이름을 그룹화
func GroupFilesByExtension(fileNames []string) map[string][]string {
	groups := make(map[string][]string)

	for _, fileName := range fileNames {
		// 파일 확장자를 추출
		baseName, extensions := GetAllExtensionsAsString1(fileName)

		// 확장자를 키로 그룹에 추가
		groups[extensions] = append(groups[extensions], baseName)
	}
	return groups
}

// IsFastqFiles fastq 파일인지
func IsFastqFiles(groups map[string][]string) (bool, error) {
	// 맵의 키 개수를 확인
	if len(groups) != 1 {
		return false, fmt.Errorf("map must contain exactly one key, but it has %d keys", len(groups))
	}

	// 맵의 첫 번째 키를 가져오기
	for ext := range groups {
		// fastq 또는 fq 포함 여부 반환
		return strings.Contains(ext, "fastq") || strings.Contains(ext, "fq"), nil
	}

	// 이 부분은 실행되지 않음 (안전성 유지용)
	return false, fmt.Errorf("unexpected error: map is empty after length check")
}

// ValidateKeyCount 키 개수 검증 메서드
func ValidateKeyCount(groupedFiles map[string][]string, maxKeys int) error {
	if len(groupedFiles) > maxKeys {
		return fmt.Errorf("error: map contains more than %d keys; found %d keys", maxKeys, len(groupedFiles))
	}
	return nil
}

/*
// 검증 실행
	err := ValidateKeyCount(groupedFiles, 1) // maxKeys를 1로 설정
	if err != nil {
		fmt.Println("Validation failed:", err)
	} else {
		fmt.Println("Validation passed: map contains acceptable number of keys.")
	}
*/

// watch.go 에서 가져 옴.
package watch

import (
	"context"
	"errors"
	"fmt"
	"github.com/fsnotify/fsnotify"
	c "github.com/seoyhaein/datablock/config"
	"log"
	"os"
	"path/filepath"
	"sync"
	"time"
)

var (
	watchCount int // 감시 디렉토리 갯수
	isWatching bool
	eventQueue []fsnotify.Event // 이벤트 큐
	queueMu    sync.Mutex       // 큐에 접근하는 뮤텍스
	once       sync.Once        // 한 번만 실행되도록 제어
	// TODO paths 의 중복확인을 해줘야 함. 물론 중복된 경우는 넘어간다고 하지만, 추가 삭제에 대한 중복확인은 해줘야 함.
	watchedPaths  = make(map[string]bool)
	maxWatchCount int
	rootDir       string
	watcher       *fsnotify.Watcher
)

func Init(path string) {

	config, err := c.LoadConfig(path)
	if err != nil {
		log.Println("loadConfig error:", err)
		return
	}
	maxWatchCount = config.MaxWatchCount
	rootDir = config.RootDir
	watcher, err = StartWatching()
	if err != nil {
		log.Println("StartWatching error:", err)
		return
	}
	// rootDir 은 이미 설정되어 있음으로 FirstWalk 내부에서 사용하고 있음. TODO: 이렇게 하는 방식은 검토할 필요가 있음.
	// TODO: FirstWalk 내부적으로 rootDir 검사하지는 않음. filepath.clean, 디렉토리인지, "" 검사등등 필요하지 않을까 생각.
	if err = FirstWalk(watcher); err != nil {
		log.Println("FirstWalk error:", err)
		return
	}
	log.Println("Initialization completed successfully.")
}

func AddWatch(watcher *fsnotify.Watcher, path string, mu *sync.Mutex) error {
	if watcher == nil {
		return fmt.Errorf("watcher is nil")
	}

	if mu != nil {
		mu.Lock()
		defer mu.Unlock()
	}

	if watchCount >= maxWatchCount {
		log.Println("Warning: Maximum watch folder count reached. Cannot add more:", path)
		return nil
	}

	err := watcher.Add(path)
	if err == nil {
		watchCount++
		log.Println("Added watch:", path, "Current watch folder count:", watchCount)
	}
	return err
}

func RemoveWatch(watcher *fsnotify.Watcher, path string, mu *sync.Mutex) error {
	if watcher == nil {
		return fmt.Errorf("watcher is nil")
	}

	if mu != nil {
		mu.Lock()
		defer mu.Unlock()
	}

	err := watcher.Remove(path)
	if err == nil {
		watchCount--
		log.Println("Removed watch:", path, "Current watch folder count:", watchCount)
		return nil
	}
	log.Println("Failed to remove watch:", err)
	return err
}

// StartWatching TODO 테스트 필요 watchCount, isWatching 를 담고 있는 구조체로 만들자.
func StartWatching() (*fsnotify.Watcher, error) {
	if isWatching {
		log.Println("Already watching.")
		return nil, errors.New("already watching")
	}
	// 새로운 watcher 생성
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return nil, err
	}
	isWatching = true

	return watcher, nil
}

// StopWatching - 감시를 중지하는 함수
func StopWatching() error {
	if watcher == nil || !isWatching {
		log.Println("No active watcher to stop.")
		return fmt.Errorf("No active watcher to stop	")
	}
	err := watcher.Close()
	if err != nil {
		log.Println("Failed to close watcher:", err)
		return err
	}
	isWatching = false
	log.Println("Stopped watching.")
	return nil
}

// ListenEvents 이벤트 처리 루프
func ListenEvents(ctx context.Context, errChan chan<- error) {
	for {
		select {
		case <-ctx.Done():
			log.Println("Stopping ListenEvents...")
			return
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}
			log.Println("Event:", event)
			addToQueue(event) // 이벤트를 큐에 추가
		case err, ok := <-watcher.Errors:
			if !ok {
				return
			}
			log.Println("Error:", err)
			select {
			case errChan <- err:
			case <-ctx.Done():
				return // 컨텍스트가 취소된 경우 반환
			}
		}
	}
}

// addToQueue 이벤트를 큐에 추가하는 함수
func addToQueue(event fsnotify.Event) {
	queueMu.Lock()
	defer queueMu.Unlock()
	eventQueue = append(eventQueue, event) // 큐에 이벤트 추가
}

// ProcessEvents 큐에서 이벤트를 하나씩 처리하는 함수 - 고루틴 사용
func ProcessEvents(ctx context.Context, errChan chan<- error) {
	var mu sync.Mutex

	for {
		select {
		case <-ctx.Done():
			log.Println("Stopping ProcessEvents...")
			return
		default:
			queueMu.Lock()
			if len(eventQueue) == 0 {
				queueMu.Unlock()
				time.Sleep(100 * time.Millisecond)
				continue
			}
			event := eventQueue[0]
			eventQueue = eventQueue[1:]
			queueMu.Unlock()

			// 이벤트 처리
			log.Println("처리 중인 이벤트:", event)
			var err error
			switch {
			case event.Has(fsnotify.Create):
				log.Println("File created:", event.Name)
				if info, err := os.Stat(event.Name); err == nil && info.IsDir() {
					if err := AddWatch(watcher, event.Name, &mu); err != nil {
						log.Printf("Failed to add watch for directory %s: %v", event.Name, err)
					}
				}
			case event.Has(fsnotify.Remove):
				log.Println("File removed:", event.Name)
				if err := RemoveWatch(watcher, event.Name, &mu); err != nil {
					log.Printf("Failed to remove watch for %s: %v", event.Name, err)
				}
			case event.Has(fsnotify.Rename):
				log.Println("File renamed:", event.Name)
				if err := RemoveWatch(watcher, event.Name, &mu); err != nil {
					log.Printf("Failed to remove watch for renamed file %s: %v", event.Name, err)
				}
			case event.Has(fsnotify.Write):
				log.Println("File modified:", event.Name)
			case event.Has(fsnotify.Chmod):
				log.Println("File attributes changed:", event.Name)
			}

			// 에러가 발생했을 경우 에러 채널로 전달
			if err != nil {
				select {
				case errChan <- fmt.Errorf("error processing event %s: %w", event.Name, err):
				case <-ctx.Done():
					return // 컨텍스트가 취소된 경우 반환
				}
			}
		}
	}
}

/*
errChan := make(chan error)

	// 고루틴에서 ProcessEvents 함수 실행
	go ProcessEvents(errChan)

	// 에러 채널에서 에러 수신
	go func() {
		for err := range errChan {
			log.Printf("Error received: %v", err)
			// 추가적인 에러 처리 로직
		}
	}()
*/

// FirstWalk TODO 최초 디렉토리 검사 및 관련 파일 만들어 주기. 감시할때는 별도의 메서드드로 관련 파일 수정 및 만들어 주어야함.
// FirstWalk TODO once 부분 리턴에 관해서 살펴봐야 함. 익명함수 내에서 리턴도 같이 봐야 함.
// 관련파일을 작성해주는 메서드를 만들어 줘야 함.
func FirstWalk(watcher *fsnotify.Watcher) error {
	var mu sync.Mutex
	var err error

	once.Do(func() {
		if watcher == nil {
			err = fmt.Errorf("watcher is nil")
			return // 익명 함수에서 반환하여 `Do` 블록의 실행 중단
		}

		// 디렉토리 순회 및 감시 추가
		err = filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() {
				return AddWatch(watcher, path, &mu)
			}
			return nil
		})
	})

	return err // once.Do 이후 최종 반환
}

// memo 파일에서 가져옴.
package main

import (
	"encoding/csv"
	"fmt"
	"github.com/seoyhaein/fileparsing/rule"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

func main() {
	// var totalfiles [][]string
	// 루트 디렉토리에서 각 디렉토리를 recursive 하게 탐색해서 파일명을 가져와야 한다.

	path := "/tmp/testfiles"
	// 테스트로 빈파일 생성
	MakeTestFiles(path)
	files, err := ReadAllFileNames1(path)
	if err != nil { // 에러 발생 시 종료
		fmt.Println("Error reading file names:", err)
		os.Exit(1)
	}
	for _, file := range files {
		fmt.Printf("%s\n", file)
	}
	r, err := rule.LoadRuleSetFromFile("./examplerule.json")
	if err != nil {
		fmt.Println("Error loading rule set.")
		os.Exit(1)
	}
	/*check := rule.ValidateRuleSet(r)
	if !check {
		os.Exit(1)
	}*/

	result, err := rule.BlockifyFilesToMap(files, r)
	if err != nil {
		log.Fatal(err)
	}
	rule.SaveResultMapToCSV("result.csv", result, r.Header)

}

// 일단 임시로 이렇게 만듬.
var (
	fileName string
	filePath string
)

// 여기에 어떻게 잘 담을지 고민해야함.
type DataBlock struct {
	Original [][]string // 원본 데이터만 저장
	RowKeys  []string   // 행 키
	ColKeys  []string   // 열 키
}

// row 에 들어가는 것.
// 확장자랑 상관없이 파일 이름이 같은 것들.

// 확장자 같은 것들
// 1_1.fastq 1_2.fastq
// 확장자가 달라도 들어갈 수 있다.

// colume 에 들어가는 것들. 확장자가 같은 것들

// datablock 으로 넣지 않아도 되는 것들. 즉 row 를 생성하지 않아도 될 것들.
// 파일이 unique 할것

// 묶을 때 다소 충돌되는 기준이 있는데 fastq 의 경우 r1, r2 를 각각의 head로 묶어야 하는데 이 기준하고
// 확장자가 다른 것들은 따로 따로 확장자별로 head 로 묶어 주는 경우가 바람직한데 이 기준하고 충돌됨.

// 파일이름이 같고(이름만 같음), 확장자가 같은 경우
// 확장자가 같은 경우
// 파일이름이 같은 것 끼리 구분 지어줌.
// 1_1.fastq 1_2.fastq 이런식으로.

// 파일이름이 같고, 확장자가 다른 경우
// 학장자가 다른 경우
// 파일 이름이 같은 것 끼리 구분 지어줌.
// 1.t1 1.t2 이런식으로.

// head 설정 기준
// 파일 이름이 다르고 확장자가 같은 경우
// 파일 이름만 다르고 나머지는 같아야 함. 또는 규칙성에 위배되지 않아야 함.
// 동일 head에 들어 갈 수 있음.

// 파일 이름이 다르고 확장자가 다른 경우
// 새로운 head 에 넣어야 함.

// 디폴트로 결정되고 -> 이 기준도 기준 파일을 만들 수 있는 형식으로.
// 사용자로 부터 구분 기준을 받는 것은 어떨까?

// DataBlock1 구조체 데이터 타입은 일단 대충 넣어둠.
type DataBlock1 struct {
	Header []string            // 헤더 데이터
	Rows   map[string][]string // 키와 값으로 구성된 데이터
}

func extractParts(fileName string) []string {
	var parts []string
	var currentPart []rune

	// 문자 유형을 판별하는 함수
	getRuneType := func(r rune) string {
		switch {
		case unicode.IsLetter(r):
			return "letter"
		case unicode.IsDigit(r):
			return "digit"
		case unicode.IsSpace(r):
			return "space"
		case unicode.IsSymbol(r):
			return "symbol"
		case unicode.IsPunct(r):
			return "punctuation"
		default:
			return "other"
		}
	}

	// 이전 문자의 유형
	var previousType string

	for _, r := range fileName {
		// 현재 문자의 유형
		currentType := getRuneType(r)

		// 현재 문자와 이전 문자의 유형이 다르면 새로운 파트 시작
		if len(currentPart) > 0 && currentType != previousType {
			parts = append(parts, string(currentPart)) // 이전 파트 저장
			currentPart = []rune{}                     // 새로운 파트 시작
		}

		// 현재 문자를 현재 파트에 추가
		currentPart = append(currentPart, r)
		previousType = currentType
	}

	// 마지막 남은 파트를 추가
	if len(currentPart) > 0 {
		parts = append(parts, string(currentPart))
	}

	return parts
}

// hasCombiningCharacter 조합문자 검출. 일단 조합문자는 막는 걸로 한다.
func hasCombiningCharacter(s string) bool {
	for _, r := range s {
		if unicode.IsMark(r) {
			return true
		}
	}
	return false
}

// 일단 유전체 데이터 일반적인 유전체 파일명 기준으로 맞추고 그것이 맞지 않는다면 별도의 파일명 기준을 찾아내는 방식으로 맞추는 방식으로 진행한다.

/*func isIlluminaParts(parts []string) bool {
	// Illumina 주요 파츠 검증
	// sample1_S1_L001_R1_001.fastq.gz를 예상
	partsCount := len(parts)
	if partsCount < 3 {
		return false
	} // 최소 3개 이상 sample.fastq (smaple . fastq)

	// "S1": 샘플 번호는 S로 시작하고 뒤에 숫자
	sampleIndex := -1
	for i, part := range parts {
		if strings.HasPrefix(part, "S") && isNumber(part[1:]) {
			sampleIndex = i
			break
		}
	}
	if sampleIndex == -1 {
		return false // S1이 없음
	}

	// "L001": 레인 번호는 L로 시작하고 뒤에 숫자
	laneIndex := -1
	for i, part := range parts {
		if strings.HasPrefix(part, "L") && isNumber(part[1:]) {
			laneIndex = i
			break
		}
	}
	if laneIndex == -1 {
		return false // L001이 없음
	}

	// "R1" 또는 "R2": 읽기 방향
	readIndex := -1
	for i, part := range parts {
		if part == "R1" || part == "R2" {
			readIndex = i
			break
		}
	}
	if readIndex == -1 {
		return false // R1 또는 R2가 없음
	}

	// "001": 반복 번호는 숫자여야 함
	repeatIndex := -1
	for i, part := range parts {
		if isNumber(part) {
			repeatIndex = i
			break
		}
	}
	if repeatIndex == -1 {
		return false // 반복 번호가 없음
	}

	// ".fastq.gz" 또는 ".fastq"로 끝나야 함
	if !strings.HasSuffix(parts[len(parts)-1], ".fastq.gz") && !strings.HasSuffix(parts[len(parts)-1], ".fastq") {
		return false // 확장자가 올바르지 않음
	}

	return true
}*/

// 이런식으로 하면 모든 확장자를 다 확인 해야 하는 어려움이 있음.
func findSuffixFastq(parts []string) (bool, string) {
	// sample.fastq 가 최소 조합임. => "sample", ".", "fastq"
	if len(parts) < 3 {
		return false, ""
	}

	if strings.HasSuffix(parts[len(parts)-1], "fastq") {
		return true, "fastq"
	}

	if strings.HasSuffix(parts[len(parts)-1], "fq") {
		return true, "fq"
	}
	// sample.fastq.gz 일 경우. => "sample", ".", "fastq", ".", "gz"
	if strings.HasSuffix(parts[len(parts)-1], "gz") {
		if strings.HasSuffix(parts[len(parts)-3], "fastq") {
			return true, "fastq.gz"
		}

		if strings.HasSuffix(parts[len(parts)-3], "fq") {
			return true, "fq.gz"
		}
	}

	return false, ""
}

// isNumber: 문자열이 숫자인지 확인
func isNumber(s string) bool {
	for _, r := range s {
		if !unicode.IsDigit(r) {
			return false
		}
	}
	return true
}

// 먼저 확장자 별로 묶어둔다.
// 특정 디렉토리에서 확장자별로 묶는다. 만약 특정 디렉토리에 확장자가 다른 것들이 있다면 각각 묶지만 에러를 리턴한다.
// 일단 파일을 묶는 것은 proto 방식으로 파일을 묶는다.

// ReadAllFileNames 특정 디렉토리에서 모든 파일 이름을 읽어오는 함수
func ReadAllFileNames(dirPath string) ([]string, error) {
	// 디렉토리의 파일 목록 읽기
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory %s: %w", dirPath, err)
	}

	// 파일 이름을 저장할 슬라이스
	var fileNames []string

	// 파일 목록에서 이름만 추출
	for _, file := range files {
		// 파일 이름을 경로와 함께 추가
		fileNames = append(fileNames, filepath.Join(dirPath, file.Name())) // Append to the End
	}

	return fileNames, nil
}

// ReadAllFileNames1 일단 임시로 만듬.
func ReadAllFileNames1(dirPath string) ([]string, error) {
	// 디렉토리의 파일 목록 읽기
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory %s: %w", dirPath, err)
	}

	// 파일 이름을 저장할 슬라이스
	var fileNames []string

	// 파일 목록에서 이름만 추출
	for _, file := range files {
		// 파일 이름을 경로와 함께 추가
		fileNames = append(fileNames, file.Name()) // Append to the End
	}

	return fileNames, nil
}

func ExtractFileParts(files []string) ([][]string, error) {
	var data [][]string
	var skippedFiles []string // 조합 문자가 포함된 파일 이름 목록

	for _, file := range files {
		if hasCombiningCharacter(file) {
			skippedFiles = append(skippedFiles, file) // 조합 문자 파일을 건너뜀
			continue
		}
		parts := extractParts(file)
		data = append(data, parts)
	}

	// 조합 문자 포함 파일이 있었는지 확인
	if len(skippedFiles) > 0 {
		errMsg := fmt.Sprintf("Skipped files with combining characters: %v", skippedFiles)
		return data, fmt.Errorf(errMsg)
	}

	return data, nil
}

func MakeTestFiles(path string) {
	// 디렉토리 생성
	err := os.MkdirAll(path, os.ModePerm)
	if err != nil {
		log.Fatalf("Failed to create directory %s: %v", path, err)
	}

	// 디렉토리 권한을 777로 설정 os.ModePerm 해줌.
	/*err = os.Chmod(path, 0777) //0o777 이 방식보다 0777 방식 사용
	if err != nil {
		log.Fatalf("Failed to set permissions for directory %s: %v", path, err)
	}*/

	// 테스트 파일 이름 목록
	fileNames := []string{
		"sample1_S1_L001_R1_001.fastq.gz",
		"sample1_S1_L001_R2_001.fastq.gz",
		"sample1_S1_L002_R1_001.fastq.gz",
		"sample1_S1_L002_R2_001.fastq.gz",
		"sample2_S2_L001_R1_001.fastq.gz",
		"sample2_S2_L001_R2_001.fastq.gz",
		"sample2_S2_L002_R1_001.fastq.gz",
		"sample2_S2_L002_R2_001.fastq.gz",
		"sample3_S3_L001_R1_001.fastq.gz",
		"sample3_S3_L001_R2_001.fastq.gz",
		"sample3_S3_L002_R1_001.fastq.gz",
		"sample3_S3_L002_R2_001.fastq.gz",
		"sample4_S4_L001_R1_001.fastq.gz",
		"sample4_S4_L001_R2_001.fastq.gz",
		"sample4_S4_L002_R1_001.fastq.gz",
		"sample4_S4_L002_R2_001.fastq.gz",
		"sample5_S5_L001_R1_001.fastq.gz",
		"sample5_S5_L001_R2_001.fastq.gz",
		"sample5_S5_L002_R1_001.fastq.gz",
		"sample5_S5_L002_R2_001.fastq.gz",
		"sample6_S6_L001_R1_001.fastq.gz",
		"sample6_S6_L001_R2_001.fastq.gz",
		"sample6_S6_L002_R1_001.fastq.gz",
		"sample6_S6_L002_R2_001.fastq.gz",
		"sample7_S7_L001_R1_001.fastq.gz",
		"sample7_S7_L001_R2_001.fastq.gz",
		"sample7_S7_L002_R1_001.fastq.gz",
		"sample7_S7_L002_R2_001.fastq.gz",
		"sample8_S8_L001_R1_001.fastq.gz",
		"sample8_S8_L001_R2_001.fastq.gz",
		"sample8_S8_L002_R1_001.fastq.gz",
		"sample8_S8_L002_R2_001.fastq.gz",
		"sample9_S9_L001_R1_001.fastq.gz",
		"sample9_S9_L001_R2_001.fastq.gz",
		"sample9_S9_L002_R1_001.fastq.gz",
		"sample9_S9_L002_R2_001.fastq.gz",
		"sample10_S10_L001_R1_001.fastq.gz",
		"sample10_S10_L001_R2_001.fastq.gz",
		"sample10_S10_L002_R1_001.fastq.gz",
		"sample10_S10_L002_R2_001.fastq.gz",
		"sample11_S11_L001_R1_001.fastq.gz",
		"sample11_S11_L001_R2_001.fastq.gz",
		"sample11_S11_L002_R1_001.fastq.gz",
		"sample11_S11_L002_R2_001.fastq.gz",
		"sample12_S12_L001_R1_001.fastq.gz",
		"sample12_S12_L001_R2_001.fastq.gz",
		"sample12_S12_L002_R1_001.fastq.gz",
		"sample12_S12_L002_R2_001.fastq.gz",
	}

	/*incompleteFileNames := []string{
		"sample1_S1_L001_R1_001.fastq.gz",
		"sample1_S1_L001_R2_001.fastq.gz",
		"sample13_S13_L001_R1.fastq.gz",
		"sample14_S14_L001_R2_001.fastq",
		"sample15_S15_L001_001.fastq.gz",
		"sample16_S16_L001.fastq.gz",
	}*/

	// 파일 생성
	for _, fileName := range fileNames {
		filePath := fmt.Sprintf("%s/%s", path, fileName)
		_, err := os.Create(filePath)
		if err != nil {
			log.Fatalf("Failed to create file %s: %v", filePath, err)
		} else {
			log.Printf("Created file: %s", filePath)
		}
	}
}

// GetAllExtensions returns all extensions in a file name as a slice of strings.
func GetAllExtensions(fileName string) []string {
	var extensions []string
	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extensions = append([]string{ext}, extensions...) // Prepend to maintain order
		fileName = strings.TrimSuffix(fileName, ext)      // Remove the last extension
	}
	return extensions
}

func GetAllExtensionsAsString(fileName string) string {
	var extensions []string
	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extensions = append([]string{ext}, extensions...) // Prepend to maintain order
		fileName = strings.TrimSuffix(fileName, ext)      // Remove the last extension
	}
	return strings.Join(extensions, "") // Concatenate all extensions
}

func GetAllExtensionsAsString1(fileName string) (baseName string, extensions string) {
	var extList []string

	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extList = append([]string{ext}, extList...)  // Prepend to maintain order
		fileName = strings.TrimSuffix(fileName, ext) // Remove the last extension
	}

	baseName = fileName
	extensions = strings.Join(extList, "") // Combine extensions

	return baseName, extensions
}

func GetAllExtensionsAsStringOptimized(fileName string) string {
	var extensions string
	for {
		ext := filepath.Ext(fileName)
		if ext == "" {
			break
		}
		extensions = ext + extensions                // Prepend directly to the result string
		fileName = strings.TrimSuffix(fileName, ext) // Remove the last extension
	}
	return extensions
}

// GroupFilesByExtension 확장자별로 파일 이름을 그룹화
func GroupFilesByExtension(fileNames []string) map[string][]string {
	groups := make(map[string][]string)

	for _, fileName := range fileNames {
		// 파일 확장자를 추출
		baseName, extensions := GetAllExtensionsAsString1(fileName)

		// 확장자를 키로 그룹에 추가
		groups[extensions] = append(groups[extensions], baseName)
	}
	return groups
}

// IsFastqFiles fastq 파일인지
func IsFastqFiles(groups map[string][]string) (bool, error) {
	// 맵의 키 개수를 확인
	if len(groups) != 1 {
		return false, fmt.Errorf("map must contain exactly one key, but it has %d keys", len(groups))
	}

	// 맵의 첫 번째 키를 가져오기
	for ext := range groups {
		// fastq 또는 fq 포함 여부 반환
		return strings.Contains(ext, "fastq") || strings.Contains(ext, "fq"), nil
	}

	// 이 부분은 실행되지 않음 (안전성 유지용)
	return false, fmt.Errorf("unexpected error: map is empty after length check")
}

// ValidateKeyCount 키 개수 검증 메서드
func ValidateKeyCount(groupedFiles map[string][]string, maxKeys int) error {
	if len(groupedFiles) > maxKeys {
		return fmt.Errorf("error: map contains more than %d keys; found %d keys", maxKeys, len(groupedFiles))
	}
	return nil
}

/*
// 검증 실행
	err := ValidateKeyCount(groupedFiles, 1) // maxKeys를 1로 설정
	if err != nil {
		fmt.Println("Validation failed:", err)
	} else {
		fmt.Println("Validation passed: map contains acceptable number of keys.")
	}
*/

func WriteCSV(data [][]string, filePath string) error {
	// CSV 파일 생성
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// CSV Writer 생성
	writer := csv.NewWriter(file)
	defer writer.Flush() // 데이터 플러시

	// 데이터를 CSV에 쓰기
	for _, row := range data {
		if err := writer.Write(row); err != nil {
			return fmt.Errorf("failed to write row: %w", err)
		}
	}

	return nil
}


// ApplyRule 적용된 규칙에 따라 파일을 처리 // TODO 추가적으로 예외 파일을 넣을 수 있도록 옵션으로 넣어 둔다.
// 해당 디렉토리에 rule.json, invalid_files, fileblock.csv 반드시 존재해아 하는데 이거 검사하는 메서드 있나??
// TODO path 나 디렉토리 관련 정규화 적용할 것. 여기서 정규화 하고 다른 메서드들은 반복되지 않도록 처리한다.
func ApplyRule(filePath string) error {
	// Load the rule set
	ruleSet, err := LoadRuleSetFromFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to load rule set: %w", err)
	}

	// Validate the rule set
	if !ValidateRuleSet(ruleSet) {
		return fmt.Errorf("rule set has conflicts or unused parts")
	}

	// Read all file names from the directory
	// 예외 규정: rule.json, invalid_files로 시작하는 파일, fileblock.csv
	exclusions := []string{"rule.json", "invalid_files", "fileblock.csv"}
	files, err := ReadAllFileNames(filePath, exclusions)

	if err != nil {
		return fmt.Errorf("failed to read file names: %w", err)
	}

	// Blockify files using the rule set
	resultMap, err := BlockifyFilesToMap(files, ruleSet)
	if err != nil {
		return fmt.Errorf("failed to blockify files: %w", err)
	}

	// Filter the result map into valid and invalid rows
	validRows, invalidRows := FilterMap(resultMap, len(ruleSet.Header))

	// Save valid rows to a CSV file
	if err := SaveResultMapToCSV(filePath, validRows, ruleSet.Header); err != nil {
		return fmt.Errorf("failed to save result map to CSV: %w", err)
	}

	// Save invalid rows to a separate file
	if err := WriteInvalidFiles(invalidRows, filePath); err != nil {
		return fmt.Errorf("failed to write invalid files: %w", err)
	}

	return nil
}

- 일단 watch 를 분리할 예정임.
- 통합한 파일정보들에서 파일들을 찾는 구문도 넣어야 함. 그리고 해당 파일 정보들을 업데이트 하는 방법도 생각해야함.
### maing.go backup
```go
package main

import (
	"bufio"
	"context"
	"github.com/seoyhaein/datablock/watch"
	"log"
	"os"
	"sync"
)

func main() {

	// Context 와 WaitGroup 정의
	ctx, cancel := context.WithCancel(context.Background())
	var wg sync.WaitGroup
	defer cancel()

	// buffer 둘것
	errChan := make(chan error, 100) // 버퍼 크기 추가
	//defer close(errChan)

	// 초기화 및 이벤트 처리
	watch.Init("config.json")
	defer watch.StopWatching()

	wg.Add(1)
	go func(ctx context.Context) {
		defer wg.Done()
		watch.ListenEvents(ctx, errChan)
	}(ctx)

	wg.Add(1)
	go func(ctx context.Context) {
		defer wg.Done()
		watch.ProcessEvents(ctx, errChan)
	}(ctx)

	// 에러 채널에서 에러 수신
	wg.Add(1)
	go func(ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				log.Println("Stopping error listener...")
				return
				/*case err, ok := <-errChan:
				if !ok {
					log.Println("Error channel closed.")
					return
				}
				// 모든 에러 출력
				log.Printf("Error received: %v", err)*/
			}
		}
	}(ctx)

	// 사용자 입력 대기
	wg.Add(1)
	go func() {
		defer wg.Done()
		log.Println("Type 'exit' to stop the watch service.")
		reader := bufio.NewReader(os.Stdin)
		for {
			input, err := reader.ReadString('\n')
			if err != nil {
				log.Printf("Error reading input: %v", err)
				continue
			}
			if input == "exit\n" {
				log.Println("Exiting watch service...")
				cancel() // Context 를 취소하여 모든 고루틴 종료
				return
			}
		}
	}()
	// TODO 당분가 삭제 금지. 이렇게 한 것을 아래 와 같이 넣었다. 기억용으로 일단 남겨둔다.
	/*
		wg.Add(1)
		go func(errChan <-chan error, ctx context.Context) {
			defer wg.Done()
			for {
				select {
				case err, ok := <-errChan:
					if !ok {
						log.Println("Error channel closed.")
						return
					}
					log.Printf("Error received: %v", err)
				case <-ctx.Done():
					log.Println("Stopping error listener...")
					// 남은 에러 처리
					for err := range errChan {
						log.Printf("Error received: %v", err)
					}
					log.Println("All errors processed. Exiting listener.")
					return
				}
			}
		}(errChan, ctx)
	*/

	// TODO 모든 고루틴이 종료될 때까지 대기 일단 주석 처리함. 테스트 끝나면 삭제.
	// log.Println("Wait...")
	wg.Wait()
	// TODO 순서를 바꾸면 에러남. 일단 테스트 진행 해야함.
	close(errChan)
	log.Println("Close Channel")
	for err := range errChan {
		log.Printf("Error received: %v", err)
	}
	log.Println("Watch service stopped gracefully.")
}

// FirstCheck_Old SQL 파일을 읽어와 폴더 및 파일 정보를 DB에 삽입. TODO 한번 만 실행되어야 함.
func FirstCheck_Old(ctx context.Context, db *sql.DB, folderPath string) error {
	if ctx == nil {
		ctx = context.Background()
	}

	if u.IsEmptyString(folderPath) {
		return fmt.Errorf("folder path is empty")
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to start transaction: %w", err)
	}

	folder := Folder{
		Path:        folderPath,
		TotalSize:   0,
		FileCount:   0,
		CreatedTime: time.Now().Format("2006-01-02 15:04:05"),
	}

	// Using embedded SQL file (insert_folder.sql)
	err = executeSQLWithTxEmbed(ctx, tx, "insert_folder.sql", folder.Path, folder.TotalSize, folder.FileCount, folder.CreatedTime)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil && !errors.Is(rbErr, sql.ErrTxDone) {
			log.Printf("rollback failed: %v", rbErr)
		}
		return fmt.Errorf("failed to insert folder: %w", err)
	}

	var folderID int64
	err = tx.QueryRowContext(ctx, "SELECT id FROM folders WHERE path = ?", folder.Path).Scan(&folderID)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil && !errors.Is(rbErr, sql.ErrTxDone) {
			log.Printf("rollback failed: %v", rbErr)
		}
		return fmt.Errorf("failed to query folder ID: %w", err)
	}

	filesInfo, err := GetFilesWithSize(folderPath)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil && !errors.Is(rbErr, sql.ErrTxDone) {
			log.Printf("rollback failed: %v", rbErr)
		}
		return fmt.Errorf("failed to retrieve files info in folder: %w", err)
	}

	for name, size := range filesInfo {
		err = executeSQLWithTxEmbed(ctx, tx, "insert_file.sql", folderID, name, size, time.Now().Format("2006-01-02 15:04:05"))
		if err != nil {
			if rbErr := tx.Rollback(); rbErr != nil && !errors.Is(rbErr, sql.ErrTxDone) {
				log.Printf("rollback failed: %v", rbErr)
			}
			return fmt.Errorf("failed to insert file: %w", err)
		}
	}

	err = executeSQLWithTxEmbed(ctx, tx, "update_folders_fromDB.sql", folderID)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil && !errors.Is(rbErr, sql.ErrTxDone) {
			log.Printf("rollback failed: %v", rbErr)
		}
		return fmt.Errorf("failed to update folder statistics: %w", err)
	}

	err = tx.Commit()
	if err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// GetFilesWithSize 특정 폴더에서 파일 이름과 해당 파일 크기를 가져오는 함수, 삭제 예정.
func GetFilesWithSize(directoryPath string) (map[string]int64, error) {
	filesInfo := make(map[string]int64)

	// 폴더 내 파일 목록 탐색 **Go 1.16 이후 부터 가능.**
	entries, err := os.ReadDir(directoryPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory %s: %w", directoryPath, err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue // 폴더는 무시하고 파일만 처리
		}

		// 파일 전체 경로
		filePath := filepath.Join(directoryPath, entry.Name())

		// 파일 정보 가져오기
		// Go 1.16 이후 부터 os.ReadDir 함수가 반환하는 DirEntry 에는 Info()메서드가 있어, 이 메서드를 사용하면 추가적인 시스템 콜 없이 파일 정보를 가져올 수 있음.
		// fileInfo, err := os.Stat(filePath) 이 코드 대신 아래 코드로 대체 가능
		fileInfo, err := entry.Info()
		if err != nil {
			return nil, fmt.Errorf("failed to get file info for %s: %w", filePath, err)
		}

		// 파일 이름과 크기 저장
		filesInfo[entry.Name()] = fileInfo.Size()
	}

	return filesInfo, nil
}

// CompareFiles_Old 는 특정 Folder 내의 파일 정보를 디스크와 DB 에서 비교함.
// 파일 목록과 크기가 일치하면 true 를, 차이가 있으면 false 와 함께 어떤 파일이 변경되었는지(FileChange 목록) 반환함.
func CompareFiles_Old(db *sql.DB, folderPath string, filesExclusions []string) (bool, []File, []FileChange, error) {
	// 디스크의 파일 정보 조회
	_, diskFiles, err := GetCurrentFolderFileInfo(folderPath, filesExclusions)
	if err != nil {
		return false, nil, nil, fmt.Errorf("failed to get folder details for %s: %w", folderPath, err)
	}
	// DB의 파일 정보 조회 (해당 Folder 에 해당하는)
	dbFiles, err := GetFilesByPathFromDB(db, folderPath)
	if err != nil {
		return false, nil, nil, fmt.Errorf("failed to get DB files for folder %s: %w", folderPath, err)
	}

	// 파일 이름을 키로 하는 맵 생성
	diskMap := make(map[string]File)
	for _, f := range diskFiles {
		diskMap[f.Name] = f
	}
	dbMap := make(map[string]File)
	for _, f := range dbFiles {
		dbMap[f.Name] = f
	}

	var changes []FileChange
	// 디스크에만 있는 파일 (추가된 파일)
	for name, diskF := range diskMap {
		if dbF, ok := dbMap[name]; !ok {
			changes = append(changes, FileChange{
				ChangeType: "added",
				Name:       name,
				DiskSize:   diskF.Size,
				DBSize:     0,
			})
		} else {
			// 파일 이름은 동일하지만 크기가 다른 경우 (수정된 파일)
			if diskF.Size != dbF.Size {
				changes = append(changes, FileChange{
					ChangeType: "modified",
					Name:       name,
					DiskSize:   diskF.Size,
					DBSize:     dbF.Size,
				})
			}
		}
	}
	// DB 에만 있는 파일 (삭제된 파일)
	for name, dbF := range dbMap {
		if _, ok := diskMap[name]; !ok {
			changes = append(changes, FileChange{
				ChangeType: "removed",
				Name:       name,
				DiskSize:   0,
				DBSize:     dbF.Size,
			})
		}
	}
	unchanged := len(changes) == 0
	return unchanged, diskFiles, changes, nil
}

// CompareFolders_Old 는 rootPath 밑의 서브 Folder 들의 통계를 디스크와 DB 에서 비교함.
// 변경 사항이 없으면 true, 변경 사항이 있으면 false 와 함께 차이 정보를 반환함.
func CompareFolders_Old(db *sql.DB, rootPath string, foldersExclusions, filesExclusions []string) (bool, []Folder, []FolderDiff, error) {
	// 디스크에서 서브 Folder 목록 조회
	diskFolders, err := GetFoldersInfo(rootPath, foldersExclusions)
	if err != nil {
		return false, nil, nil, fmt.Errorf("failed to get subfolders from disk: %w", err)
	}
	// DB 에서 Folder 정보 조회
	dbFolders, err := GetFoldersFromDB(db)
	if err != nil {
		return false, nil, nil, fmt.Errorf("failed to get folders from DB: %w", err)
	}
	// DB Folder 정보를 경로 기준으로 맵으로 구성
	dbFolderMap := make(map[string]Folder)
	for _, f := range dbFolders {
		dbFolderMap[f.Path] = f
	}

	var diffs []FolderDiff
	// 디스크의 각 Folder 에 대해 파일 통계를 갱신한 후 DB와 비교
	for _, diskFolder := range diskFolders {
		updatedFolder, _, err := GetCurrentFolderFileInfo(diskFolder.Path, filesExclusions)
		if err != nil {
			return false, nil, nil, fmt.Errorf("failed to get folder details for %s: %w", diskFolder.Path, err)
		}
		if dbFolder, ok := dbFolderMap[diskFolder.Path]; !ok {
			// DB에 해당 Folder 정보가 없는 경우
			diffs = append(diffs, FolderDiff{
				Path:          diskFolder.Path,
				DiskTotalSize: updatedFolder.TotalSize,
				DBTotalSize:   0,
				DiskFileCount: updatedFolder.FileCount,
				DBFileCount:   0,
			})
		} else {
			if updatedFolder.TotalSize != dbFolder.TotalSize || updatedFolder.FileCount != dbFolder.FileCount {
				diffs = append(diffs, FolderDiff{
					Path:          diskFolder.Path,
					DiskTotalSize: updatedFolder.TotalSize,
					DBTotalSize:   dbFolder.TotalSize,
					DiskFileCount: updatedFolder.FileCount,
					DBFileCount:   dbFolder.FileCount,
				})
			}
		}
	}
	unchanged := len(diffs) == 0
	return unchanged, diskFolders, diffs, nil
}

// CompareFoldersAndFiles_old TODO 이거 생각할 거 많음. 같지 않을때 어떻게 처리할지 생각해야함. 같지 않을때는 db 를 업데이트 해야 할 거 같음. context 생각해보기.
func (f *dBApisImpl) CompareFoldersAndFiles_old(ctx context.Context, db *sql.DB) (*bool, error) {
	// 폴더 비교: foldersMatch, folders, <unused>, err
	foldersMatch, folders, _, err := d.CompareFolders(db, f.rootDir, f.foldersExclusion, f.filesExclusions)
	if err != nil {
		return nil, err
	}
	if !foldersMatch {
		return u.PFalse, nil
	}

	// 각 폴더별 처리
	for _, folder := range folders {
		// 먼저, 해당 폴더 내 파일들을 비교
		filesMatch, files, _, err := d.CompareFiles(db, folder.Path, f.filesExclusions)
		if err != nil {
			return nil, err
		}
		if !filesMatch {
			return u.PFalse, nil
		}

		// 파일과 폴더가 동일한 경우, 특수 파일 존재 여부를 확인
		special, err := SpecialFilesExist(folder.Path)
		if err != nil {
			return nil, err
		}
		// 특수 파일이 이미 존재하면 새로 생성할 필요가 없으므로 건너뜀
		if special != nil && *special {
			continue
		}

		// 특수 파일이 없으면, 파일 목록을 추출하고 GenerateFileBlock 실행
		fileNames := d.ExtractFileNames(files)
		if _, err := r.GenerateFileBlock(folder.Path, fileNames); err != nil {
			return nil, err
		}
	}
	return u.PTrue, nil
}

```

.golangci.yml
```yaml
run:
  timeout: 2m                # 실행 시간 제한 (2분)
  issues-exit-code: 1         # 린트 오류 발생 시 CI에서 실패 처리

linters:
  enable:
    - govet                  # Go 기본 정적 분석 도구
    - revive                 # golint 대신 사용하는 코드 스타일 검사기
    - staticcheck            # 심층적인 코드 분석 및 최적화 검사
    - ineffassign            # 할당 후 사용되지 않는 값 감지
    - errcheck               # 오류 반환 값을 무시하는 경우 감지
    - gocyclo                # 함수의 순환 복잡도 분석 (복잡도 15 이상 경고)
    - deadcode               # 사용되지 않는 코드 감지
    - structcheck            # 사용되지 않는 구조체 필드 감지
    - varcheck               # 사용되지 않는 변수 감지
    - unused                 # 사용되지 않는 코드 감지
  disable:
    - scopelint              # Go 1.14 이후 불필요한 검사 비활성화

issues:
  exclude-rules:
    - path: ".*_test.go"      # 테스트 코드에서는 린트 오류 무시
      linters:
        - revive
        - govet
    - linters:
        - errcheck          # "error return value not checked" 경고 무시
      text: "error return value not checked"
  exclude:                  # 특정 경고 메시지 무시
    - "should have comment"         # 모든 함수에 주석 요구 경고 무시
    - "don't use underscores in Go names"  # 언더스코어 사용 경고 무시

linters-settings:
  gocyclo:
    min-complexity: 15      # 순환 복잡도 15 이상일 때 경고
#  govet:
#    check-shadowing: true   # 변수 그림자(shadowing) 감지 활성화
  errcheck:
    check-type-assertions: true  # 타입 변환 관련 오류 감지 활성화
#  unused:
#    check-exported: true    # 사용되지 않는 외부 변수 검사

#cache:
#  enabled: true             # 캐시 활성화 (속도 향상)

output:
  out-format: colored-line-number  # 색상이 있는 출력 형식
  sort-results: true               # 정렬된 결과 표시

#parallel: true              # 병렬 실행 활성화 (자동 최적화)



// SpecialFilesExist 파일이 하나라도 있으면 PTrue, 모두 없으면 PFalse, 에러 발생 시 nil 반환
func SpecialFilesExist(folder string) (*bool, error) {
	// 고정 파일명 체크: rule.json, fileblock.csv
	filesToCheck := []string{"rule.json", "fileblock.csv"}
	for _, fileName := range filesToCheck {
		path := filepath.Join(folder, fileName)
		if _, err := os.Stat(path); err == nil {
			return u.PTrue, nil
		} else if !os.IsNotExist(err) {
			// err != nil 이면서 os.IsNotExist(err)인 경우는, 파일이 없는 게 아니라 권한 문제 등 예상치 못한 오류가 발생한 경우
			return nil, fmt.Errorf("failed to check %s: %w", path, err)
		}
	}

	// 패턴 체크: invalid_files* 와 *.pb
	patterns := []string{"invalid_files*", "*.pb"}
	for _, pattern := range patterns {
		fullPattern := filepath.Join(folder, pattern)
		matches, err := filepath.Glob(fullPattern)
		if err != nil {
			return nil, fmt.Errorf("failed to search for files with pattern %s: %w", pattern, err)
		}
		if len(matches) > 0 {
			return u.PTrue, nil
		}
	}

	return u.PFalse, nil
}

// CompareFoldersAndFiles 폴더와 파일을 비교하고, 변경 내역을 반환
func (f *dBApisImpl) CompareFoldersAndFiles(ctx context.Context, db *sql.DB) (*bool, []d.FolderDiff, []d.FileChange, []*protos.FileBlockData, error) {
	// 1. 폴더 비교: 폴더 목록과 폴더 간 차이 정보를 가져옴
	_, folders, folderDiffs, err := d.CompareFolders(db, f.rootDir, f.foldersExclusion, f.filesExclusions)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	var allFileChanges []d.FileChange
	var fbs []*protos.FileBlockData // 파일 블록 데이터 슬라이스

	// 2. 각 폴더에 대해 파일 비교
	for _, folder := range folders {
		// 파일 비교
		filesMatch, files, fileChanges, err := d.CompareFiles(db, folder.Path, f.filesExclusions)
		if err != nil {
			return nil, nil, nil, nil, err
		}
		// 해당 폴더에 파일이 다르다면 db 업데이트 후 rule.json 을 제외하고 모든 것을 다시 만들어 줘야 함.
		if !filesMatch {
			allFileChanges = append(allFileChanges, fileChanges...)
		} else {
			// 파일과 폴더가 db 와 동일한 경우, 특수 파일 존재 여부를 확인
			// rule 이 없으면 무조건 에러 리턴.

			_, err := FileExistsExact(folder.Path, "rule.json")
			//special, err := SpecialFilesExist(folder.Path)
			if err != nil {
				return nil, nil, nil, nil, err
			}

			bfb, err := FileExistsExact(folder.Path, "fileblock.csv")
			pbs, err := SearchFilesByPattern(folder.Path, "*.pb")
			// 만약 pbs 가 여러개 있거나 없으면. 해당 파일을 지우고 새롭게 만들어 줘야함.
			if len(pbs) > 1 {
				if err = DeleteFilesByPattern(folder.Path, "*.pb"); err != nil {
					return nil, nil, nil, nil, err
				}
				// 초기화 시켜야함.
				pbs = []string{}
			}
			// rule 이 있고 *pb 파일과, csv 파일이 있으면 건더 뜀. 어느 하나라도 없으면 만들어줌.
			if bfb && len(pbs) == 1 {
				fbPath := filepath.Join(folder.Path, pbs[0])
				fb, err := v1rpc.LoadFileBlock(fbPath)
				// 에러 나오면 그냥 리턴함.
				if err != nil {
					return nil, nil, nil, nil, err
				}
				fbs = append(fbs, fb)
				continue
			}

			// []Files 를 []string 으로 변환 여기에는 파일이름만 들어감. GenerateFileBlock 실행
			fileNames := d.ExtractFileNames(files)

			// fileblock.csv, invalid_files, *.pb 파일 만들어줌.
			fb, err := r.GenerateFileBlock(folder.Path, fileNames)

			// 만들어 준것을 넣어줌.
			if err != nil {
				return nil, nil, nil, nil, err
			}
			fbs = append(fbs, fb)
		}
	}

	// 전체 동일 여부: 폴더 차이와 파일 변경 내역이 없으면 true, 아니면 false
	overallSame := len(folderDiffs) == 0 && len(allFileChanges) == 0
	if overallSame {
		return u.PTrue, nil, nil, fbs, nil
	}
	return u.PFalse, folderDiffs, allFileChanges, fbs, nil
}

```